= The Meaning of Types

One of the most common "code smells" that I've come across is one that goes by the name "Primitive Obsession". No, it's not a men's fragrance by Calvin Kline. It refers to the tendency that many developers seem to have to not want to define custom classes to model the problem domains for which they are developing software. More specifically, "Primitive Obsession" is the use of "primitive' or other built-in data types to represent domain concepts, rather than defining custom types to represent those concepts.

As best I can tell, the primary reasons that this code smell is so prevalent are 1) laziness on the part of the developer (a noble trait, but misguided in this case) and 2) ignorance of the "right way" to model their doamin. In this article, I'll try to address both of these reasons.

== Exemplī Grātiā

In a past life, I worked as a consultant on a rather large Java project for a very large and important financial institution. The project was involved with trading certain types of financial securities. The standard way to identifying a financial security (in North America, at least) is the _CUSIP_ (which, incidentally, stands for _Committee on Uniform Security Identification Procedures_), a nine-character alphanumeric code that acts as a universal unique identifier for any security. The exact mechanism of generating CUSIPs is up to the institution issuing the security, but there are certain validation rules that can be applied, which are mainly intended to catch mistakes during manual data entry. For instance, the characters "I" and "O" are banned because they might be mistaken for "1" or "0", and the last character in each CUSIP acts as a checksum. 

Given such an important domain concept with well-defined validation rules, one would hope that all CUSIPs in the system would be represented by a dedicated `CUSIP` class that enforces those rules. However, as you might guess from the subject of this article, when I joined the project, these values were instead being represented as plain Java `String` objects throughout the system. There were XML schemas defined for the messages that were passed between system components, but even there, the validation rules merely indicated "9-character string" with no further validation beyond that, and no custom type bindings for the JAXB classes that were being generated to represent these messages.

As a result, a typical service interface that worked with CUSIPs might look like this:

----
public interface SecurityLookupService {
   Security findSecurityByCUSIP(String cusip) throws SecurityNotFoundException;
----

Let's consider the implications of representing CUSIPs as plain `String` objects.

First of all, the `String` class comes with no implication of any validation having been performed on its value. This means that any code that works with CUSIPs as `String` instances must make one of two assumptions:

1. Assume that any `String` it receives is potentially invalid and therefore defensively validate every input. In a large system, this means that *every* CUSIP may be validated many times as it moves throughout the system, and the validation logic will be repeated in every piece of code that works with CUSIPs. In the case of the above example interface, this might mean either throwing an `IllegalArgumentException` in this case, or simply throwing a `SecurityNotFoundException`, though I would argue that the latter solution would be undesirable, since the caller would not be able to tell whether the exception was thrown due to an invalid value or if the security was simply missing from the system.
2. Blindly assume that any `String` it receives has already been validated _somewhere_, and pray that there is no way for a CUSIP to enter the system via a path that does not include this validation.

As you can see, both of these assumptions seem fundamentally flawed. In one, (hopefully) the same code will be duplicated all over the place (and perhaps not even consistently) and all callers would need to accept the possibility that a method call might value due to validation. In the other, everyone is putting blind faith into the idea that someone else has already done the work. Furthermore, there is no guarantee that every developer working on the system will make the same assumption, so you may see both approaches being used in various parts of the system.

An interesting - and disturbing - fact that I discovered in the course of investigating this state of affairs was that many, if not most, of the developers working on the project were not even aware of what a valid CUSIP should look like. Why should they? They weren't responsible for generating CUSIPs, and for the most part, they were just being treated as opaque values. However, an unfortunate side effect of this was that many developers were just using arbitrary strings as CUSIPs in the tests they wrote, and most of those strings were very clearly *not* valid CUSIPs. This meant that if someone made a change that added CUSIP validation logic somewhere that it did not previously exist, it would, in fact, cause these tests to fail. Indeed, I discovered that the test data being generated by the test team contained many invalid CUSIPs and other types of values. This meant that tests were effectively being written to verify that the system would accept data it should not have accepted! Given that the system needed to talk to external systems using these values in the course of performing multimillion-dollar financial transactions, this was not a very good situation.


